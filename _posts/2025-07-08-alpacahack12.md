---
title: 'AlpacaHack Round 12 (Crypto)'
date: 2025-07-08
categories: [ctf]
tags: [Crypto]     
published: true
description: "Wu cho giải AlpacaHack Round 12"
---

## RSARSARSARSARSARSA

Source code của bài:

```python
from math import gcd
import os
from Crypto.Util.number import getPrime, bytes_to_long

e = 19
while True:
    p = getPrime(2048)
    q = getPrime(2048)
    if gcd((p - 1) * (q - 1), e) == 1:
        break
n = p * q

flag = os.environ.get("FLAG", "Alpaca{**** REDACTED ****}")
assert len(flag) == 26 and flag.startswith("Alpaca{") and flag.endswith("}")

m = bytes_to_long((flag * 1337).encode())
c = pow(m, e, n)

print(f"{n = }")
print(f"{e = }")
print(f"{c = }")
'''
n = 434245275129793896913302623186216967500119715299127153234221039838158526818290666891561167619572507897277032319251523352710966722158326513857889678449160348496647427753832233179173745189495799707833020232209447520485615893168704144655033371807912826948460011240258726843346618328839282439390863464375320181495406806870462330735361196286553150480225927729088313551861682406252457739974850015509783430978939475350707211461876140420181118923743456062581297038004651412953310377554877499792225388059857865550418697212704277742826280689987165702071346542831836616149138379224837551040036947064990027047482745931141458056028719767845142490618375017582275824317241572815337810658684051187938258804346960781372035972758516593800419459342799854863845667715099378564373594732798224797622583907677749880918106223965727445907355069025939554400938193579295415911074889648122298896605189398591684277376327938718166279159875826993866460251900514487349848332991005775574378131897581182876147580659857596204121970624162722935263271888969020482566142620134100258216288390250174699829806817678453601913377347867137739622906815272561714188564065071077762169177825466514512198167566882661748389120146622447920498988341055543170346944366105037929197965527
e = 19
c = 78338816976998323261765735600063671710448529902850366859501110834174319629348492230679353792803618614020892663940158627385470036549819116375194598599193512981265682997072278631964394686243958989105159463105190885437258093111178664394786430767942639437287236999171486583513816766766869843448941665224796216610702708658300011987744401747551989248270799179750556330952646223694000679475842632497149402602469848595868051660228892506097962300820851000134370939783634534516434054009303981106884637932006844265722691022870174977860945699441650254771777451995160642261482879537396171107016491225773397809485749640163676209732235156461483660111845782227127763086286553520914359194795617080980736767821995556156173267185240945707717461037831992544868933876015548419376861213017988005848033349136839971120363078490938026883354839573512645985195570831018461470031329716026531550172207332072481279548470657090575709419245114386419567236219816237412255505882075283974654569995321334498673793010812162088796252555619242463561750801895032793870706949913548310632113206159695535952422316840587214237406730422405058644629458566515378607614900910335034732797410592671297941526063690060922625005949094383664832255082556088451940780657576420871470920836
'''
```
Có hai điểm đáng chú ý ở bài này: Đầu tiên số mũ lập mã $\displaystyle e$ khá nhỏ so với modulo và flag được lặp cấu trúc lại nhiều lần. 

Đầu tiên với $\displaystyle b$ bất kì thì hàm `bytes_to_long` sẽ chuyển đổi giá trị từ bytes sang số nguyên như sau

$$\begin{equation*}
bytes-to-long(b)=\sum_{i=0}^{len( b) -1} b[ i] \times 256^{len( b) -1-i}
\end{equation*}$$


Mà flag được lặp lại 1337 lần cho nên 

$$\begin{equation*}
m=\underbrace{f\| f\| ...\| f}_{1337}
\end{equation*}$$

Cho nên 

$$\begin{gather*}
m=f\times 256^{26( 1337-1)} +f\times 256^{26( 1337-2)} +...+f\times 256^{0}\\
\Longrightarrow m=f\times \sum_{i=0}^{k-1} B^{li}
\end{gather*}$$

trong đó $\displaystyle l=26$ là độ dài của flag và $\displaystyle k=1337,B=256$. Ta sẽ tính small roots ở bước kế tiếp. Cụ thể

$$\begin{equation*}
c=m^{e} =( f\times S)^{e}\bmod n
\end{equation*}$$

trong đó $\displaystyle S=\sum _{i=0}^{1336} 256^{26i}$. Suy ra $\displaystyle f^{e} =c\times S^{-e}\bmod n$. Đa thức mà ta khởi tạo sẽ là $\displaystyle f( x) =x^{e} -c'\bmod n$ với $\displaystyle c'=c\times S^{-e}$

Solve script:

```python
from sage.all import *
from Crypto.Util.number import *
n = 434245275129793896913302623186216967500119715299127153234221039838158526818290666891561167619572507897277032319251523352710966722158326513857889678449160348496647427753832233179173745189495799707833020232209447520485615893168704144655033371807912826948460011240258726843346618328839282439390863464375320181495406806870462330735361196286553150480225927729088313551861682406252457739974850015509783430978939475350707211461876140420181118923743456062581297038004651412953310377554877499792225388059857865550418697212704277742826280689987165702071346542831836616149138379224837551040036947064990027047482745931141458056028719767845142490618375017582275824317241572815337810658684051187938258804346960781372035972758516593800419459342799854863845667715099378564373594732798224797622583907677749880918106223965727445907355069025939554400938193579295415911074889648122298896605189398591684277376327938718166279159875826993866460251900514487349848332991005775574378131897581182876147580659857596204121970624162722935263271888969020482566142620134100258216288390250174699829806817678453601913377347867137739622906815272561714188564065071077762169177825466514512198167566882661748389120146622447920498988341055543170346944366105037929197965527
e = 19
c = 78338816976998323261765735600063671710448529902850366859501110834174319629348492230679353792803618614020892663940158627385470036549819116375194598599193512981265682997072278631964394686243958989105159463105190885437258093111178664394786430767942639437287236999171486583513816766766869843448941665224796216610702708658300011987744401747551989248270799179750556330952646223694000679475842632497149402602469848595868051660228892506097962300820851000134370939783634534516434054009303981106884637932006844265722691022870174977860945699441650254771777451995160642261482879537396171107016491225773397809485749640163676209732235156461483660111845782227127763086286553520914359194795617080980736767821995556156173267185240945707717461037831992544868933876015548419376861213017988005848033349136839971120363078490938026883354839573512645985195570831018461470031329716026531550172207332072481279548470657090575709419245114386419567236219816237412255505882075283974654569995321334498673793010812162088796252555619242463561750801895032793870706949913548310632113206159695535952422316840587214237406730422405058644629458566515378607614900910335034732797410592671297941526063690060922625005949094383664832255082556088451940780657576420871470920836
bound = 2 ** (8 * 26)
S = sum([256 ** (26 * i) for i in range(1337)])
S_inv_e = pow(S, -e, n)
c_prime = (c * S_inv_e) % n
PR = PolynomialRing(Zmod(n), 'x')
x = PR.gen()
f = x**e - c_prime
roots = f.small_roots(X=bound, beta=0.4)
for r in roots:
    try:
        temp = int(r).to_bytes(26, 'big')
        if b"Alpaca{" in temp and temp.endswith(b"}"):
            print(temp.decode())
            break
    except:
        continue
else:
    print("fail")
```

## OTEC

Source code:

```python
import os
import signal
import secrets
from fastecdsa.curve import secp256k1
from fastecdsa.point import Point
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Util.number import long_to_bytes

signal.alarm(60)

flag = os.environ.get("FLAG", "Alpaca{**** REDACTED ****}").encode()

# Oblivious Transfer using Elliptic Curves
G = secp256k1.G
a = secrets.randbelow(secp256k1.q)
A = a * G

print(f"{A.x = }")
print(f"{A.y = }")

x, y = map(int, input("B> ").split(","))
B = Point(x, y, secp256k1)

k0 = long_to_bytes((a * B).x, 32)
k1 = long_to_bytes((a * (B - A)).x, 32)

def encrypt(message, key):
    return AES.new(key, AES.MODE_ECB).encrypt(pad(message, 16))

print(encrypt(flag[0::3], k0).hex())
print(encrypt(flag[1::3], k1).hex())
print(encrypt(flag[2::3], bytes(c0 ^ c1 for c0, c1 in zip(k0, k1))).hex())
```
Tóm tắt: Bài kết hợp giữa Oblivious Transfer và ECC. Cụ thể nó sẽ tính hai giá trị $\displaystyle k_{0} ,k_{1}$ từ input và dùng làm key để mã hóa flag. Tiếp theo ta quan sát cách mà $\displaystyle k_{0} ,k_{1}$ được tính

$$\begin{gather*}
k_{0} =aB_{x}\\
k_{1} =a( B-A)_{x}
\end{gather*}$$

Nó sẽ lấy tọa độ $\displaystyle x$ của các điểm trên. Để giải bài này thì ta cần gửi 3 lần với 3 điểm $\displaystyle B$ khác nhau.



Đầu tiên để tính lại $\displaystyle k_{0}$ thì ta cần gửi $\displaystyle B=G$ thì lúc này $\displaystyle k_{0} =aG_{x} =A_{x}$ và giá trị này server cho ta biết mỗi lần truy vấn đến.

Tiếp theo là $\displaystyle k_{1}$. Ta có thể tính được giá trị này bằng cách cho $\displaystyle B=G+A$. Khi đó 

$$\begin{equation*}
a( B-A) =aG=A
\end{equation*}$$

Cuối cùng là làm thế nào để tính $\displaystyle k_{0} \oplus k_{1}$. Cách đơn giản nhất là làm cho giá trị này triệt tiêu bằng cách chọn $\displaystyle B=\frac{A}{2}$. Thì khi đó 

$$\begin{gather*}
k_{0} =\frac{aA}{2}[x]\\
k_{1} =\frac{-aA}{2}[x]
\end{gather*}$$

Và khi xor hai giá trị này lại thì ta được NULL key. Do ta đang làm việc trên nhóm các điểm trên đường cong nên phép chia 2 tương đương với phép nhân nghịch đảo theo modulo order. 



Script solve:
```python
from pwn import remote
from fastecdsa.curve import secp256k1
from fastecdsa.point import Point
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Util.number import long_to_bytes
from itertools import zip_longest

def decrypt(ciphertext, key):
    return unpad(AES.new(key, AES.MODE_ECB).decrypt(ciphertext), 16)

host = "34.170.146.252"
port = 62340
G = secp256k1.G

def get_flag_part_1():
    r = remote(host, port)
    A_x = int(r.recvline().decode().split('=')[1])
    A_y = int(r.recvline().decode().split('=')[1])
    A = Point(A_x, A_y, secp256k1)
    r.sendline(f"{G.x}, {G.y}".encode())
    r.recvuntil('B>')
    ct0 = r.recvline().decode().strip()
    ct1 = r.recvline().decode().strip()
    ct2 = r.recvline().decode().strip()
    ct0_bytes = bytes.fromhex(ct0)
    key = long_to_bytes(A.x, 32)
    r.close()
    return decrypt(ct0_bytes, key)

def get_flag_part_2():
    r = remote(host, port)
    A_x = int(r.recvline().decode().split('=')[1])
    A_y = int(r.recvline().decode().split('=')[1])
    A = Point(A_x, A_y, secp256k1)
    B = G + A
    r.sendline(f"{B.x}, {B.y}".encode())
    r.recvuntil('B>')
    ct0 = r.recvline().decode().strip()
    ct1 = r.recvline().decode().strip()
    ct2 = r.recvline().decode().strip()
    ct1_bytes = bytes.fromhex(ct1)
    key = long_to_bytes(A.x, 32)
    r.close()
    return decrypt(ct1_bytes, key)

def get_flag_part_3():
    r = remote(host, port)
    A_x = int(r.recvline().decode().split('=')[1])
    A_y = int(r.recvline().decode().split('=')[1])
    A = Point(A_x, A_y, secp256k1)
    order = secp256k1.q
    scale = pow(2, -1, order)
    B = A * scale
    r.sendline(f"{B.x}, {B.y}".encode())  
    r.recvuntil('B>')
    ct0 = r.recvline().decode().strip()
    ct1 = r.recvline().decode().strip()
    ct2 = r.recvline().decode().strip()
    ct2_bytes = bytes.fromhex(ct2)
    key = bytes([0] * 32)
    r.close()
    return decrypt(ct2_bytes, key)

if __name__ == "__main__":
    flag0 = get_flag_part_1()
    flag1 = get_flag_part_2()
    flag2 = get_flag_part_3()
    full_flag = bytes(
        [c for tup in zip_longest(flag0, flag1, flag2) for c in tup if c is not None]
    )
    print(full_flag.decode())
```
