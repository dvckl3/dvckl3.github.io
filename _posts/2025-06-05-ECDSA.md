---
title: 'ECDSA Cracking Methods'
date: 2025-06-05
categories: [ctf]
tags: [Crypto]     
published: true
description: "Chữ kí số dựa trên Elliptic Curve"
---
## ECDSA's Scheme
Lược đồ chữ kí số ECDSA bao gồm các thành phần sau: Đầu tiên là một khóa bí mật $\displaystyle d$ và khóa công khai sẽ được tính bởi $\displaystyle Q=d.G$ trong đó $\displaystyle G$ là generator của elliptic curve có order là $\displaystyle n$.

Như vậy $\displaystyle \left(\text{pk} ,\text{sk}\right) =( d,Q)$

![image](https://github.com/user-attachments/assets/c4ddb00f-de89-4cb2-a52c-709e7bc770ff)


**Tạo chữ kí:**

Với message $\displaystyle ( m)$, mục tiêu của ta là dùng priv key để tạo ra một cặp chữ kí $\displaystyle ( r,s)$. Đầu tiên ta cần sử dụng một nonce $\displaystyle k$ để tính giá trị của 

$$\begin{equation*}
P=kG
\end{equation*}$$

Khi đó ta sẽ lấy 

$$\begin{equation*}
r=P_{x}(\bmod n)
\end{equation*}$$

Tiếp theo ta sẽ tính $\displaystyle s$ như sau

$$\begin{equation*}
s=k^{-1}( e+dr)(\bmod n)
\end{equation*}$$

trong đó $\displaystyle e=H( m)$ với $\displaystyle H$ là một hàm Hash. 

Vậy ta có cặp $\displaystyle ( r,s)$ là chữ kí số của msg $\displaystyle m$. 



**Xác minh chữ kí:**

Để xác minh chữ kí số $\displaystyle ( m,( r,s))$ ta làm như sau:

Ta sẽ tính $\displaystyle e=H( m)$. Sau đó sẽ tính 


$$\begin{gather*}
w=s^{-1}(\bmod n)\\
u_{1} =ew\\
u_{2} =rw
\end{gather*}$$

Tiếp theo:

$$\begin{gather*}
X=u_{1} G+u_{2} Q\\
x=X_{x}(\bmod n)
\end{gather*}$$

và kiểm tra xem $\displaystyle x=r$ thì chữ kí là hợp lệ.



Vì sao ta lại có $\displaystyle x=r?$.



Đầu tiên ta xét 

$$\begin{equation*}
P=kG
\end{equation*}$$

Và $\displaystyle Q=dG$ cho nên 

$$\begin{gather*}
X=u_{1} G+u_{2} Q=u_{1} G+u_{2} dG\\
=( u_{1} +u_{2} d) G
\end{gather*}$$

Vậy ta cần chỉ ra $\displaystyle u_{1} +u_{2} d\equiv k(\bmod n)$. Cụ thể 

$$\begin{gather*}
w=s^{-1}(\bmod n)\\
\Longrightarrow ew+rwd=w( e+rd) =sks^{-1} =k(\bmod n)
\end{gather*}$$

Lưu ý rằng khi làm việc trên đường cong Elliptic thì 

$$\begin{equation*}
aG=bG
\end{equation*}$$

khi và chỉ khi $\displaystyle a\equiv b\bmod G.order()$. Ở đây order là $\displaystyle n$ cho nên ta có điều phải chứng minh.

## Breaking ECDSA

Sẽ có một vài trường hợp mà tại đó lược đồ ECDSA không còn an toàn nữa. 

### Revealed nonce

Trong trường hợp người kí để lộ nonce dù chỉ một lần, thì attacker có thể khôi phục lại privkey bằng cách tính 

$$\begin{equation*}
priv\ =\ ( sk-e) r^{-1}\bmod n
\end{equation*}$$

Ta cần có $\displaystyle ( r,n) =1$ để tồn tại nghịch đảo modulo. Trên thực tế thì điều này hoàn toàn được đảm bảo vì các đường cong được dùng cho chữ kí số thường có order là một số nguyên tố lớn. 

### Nonce Reuse

Trường hợp nonce được dùng lại và ta có 2 chữ kí số của 2 văn bản khác nhau:


$$\begin{gather*}
r_{1} =kG\\
s_{1} =k^{-1}( H( m_{1}) +dr)\\
r_{2} =kG\\
s_{2} =k^{-1}( H( m_{2}) +dr)
\end{gather*}$$

Trong đó $\displaystyle d$ là privkey. Ta sẽ khôi phục lại giá trị này như sau:


$$\begin{gather*}
s_{1} k=H( m_{1}) +dr\\
s_{2} k=H( m_{2}) +dr\\
\Longrightarrow s_{1} k-s_{2} k=H( m_{1}) -H( m_{2})\\
\Longrightarrow k=\frac{H( m_{1}) -H( m_{2})}{s_{1} -s_{2}}
\end{gather*}$$

Sau khi có được $\displaystyle k$ thì ta hoàn toàn tính được priv từ công thức ở trên. Cụ thể 


$$\begin{gather*}
\frac{s_{2} H( m_{1}) -s_{1} H( m_{2})}{r( s_{1} -s_{2})} =priv\\
priv\ =\ ( sk-H( m_{1})) r^{-1}
\end{gather*}$$

### Two keys and shared nonce

Như ta đã biết thì ECDSA là non-deterministic, tức là mỗi lần kí cho cùng 1 msg sẽ cho ra 2 kết quả khác nhau. Lý do là vì ta sử dụng số $\displaystyle k$ là một nonce cho nên các giá trị sẽ được random. Attacks này xảy ra khi người kí, ta tạm gọi là Alice, kí 4 msgs khác nhau với 2 keys và 2 nonces.



Cụ thể như sau: Alice kí 2 msgs $\displaystyle ( m_{1}) ,( m_{2})$ với hai priv key khác nhau là $\displaystyle x_{1} ,x_{2}$ nhưng dùng chung 1 nonce là $\displaystyle k_{1}$. Tương tự với 2 msgs $\displaystyle ( m_{3}) ,( m_{4})$ với hai priv key $\displaystyle x_{1} ,x_{2}$ và một nonce khác là $\displaystyle k_{2}$.

Bây giờ ta sẽ tính được từ hàm Hash các giá trị sau:


$$\begin{equation*}
h_{i} =H( m_{i}) ,i=\overline{1,4}
\end{equation*}$$

Và ta có 4 chữ kí

$$\begin{gather*}
s_{1} =k_{1}^{-1}( h_{1} +r_{1} x_{1})\\
s_{2} =k_{1}^{-1}( h_{2} +r_{1} x_{2})\\
s_{3} =k_{2}^{-1}( h_{3} +r_{2} x_{1})\\
s_{4} =k_{2}^{-1}( h_{4} +r_{2} x_{2})
\end{gather*}$$

Trong đó $\displaystyle r_{1} =k_{1} G,r_{2} =k_{2} G$. Ta có thể dùng khử gauss để tính lại 

$$\begin{gather*}
x_{1} =\frac{h_{1} r_{2} s_{2} s_{3} -h_{2} r_{2} s_{1} s_{3} -h_{3} r_{1} s_{1} s_{4} +h_{4} r_{1} s_{1} s_{3}}{r_{1} r_{2}( s_{1} s_{4} -s_{2} s_{3})}\\
x_{2} =\frac{h_{1} r_{2} s_{2} s_{4} -h_{2} r_{2} s_{1} s_{4} -h_{3} r_{1} s_{1} s_{4} +h_{4} r_{1} s_{1} s_{3}}{r_{1} r_{2}( s_{2} s_{3} -s_{1} s_{4})}
\end{gather*}$$


Ở đây do dùng 2 priv key khác nhau cho nên kể cả khi biết $\displaystyle s_{1} ,s_{2}$ thì ta cũng không khôi phục lại nonce $\displaystyle k_{1}$ được. Cách duy nhất là giải hệ phương trình. 
