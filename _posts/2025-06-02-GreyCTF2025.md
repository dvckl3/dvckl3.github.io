---
title: 'Grey Cat The Flag CTF 2025'
date: 2025-06-02 
categories: [ctf]
tags: [Crypto]     
published: true
description: "Wu một số bài trong giải Grey CTF 2025"
---
# Crypto/Uwusignatures
Source code của bài:

```python
from Crypto.Util.number import *
import json
import hashlib

KEY_LENGTH = 2048
FLAG = "grey{fakeflagfornow}"

class Uwu:
    def __init__(self, keylen):
        self.p = getPrime(keylen)
        self.g = getRandomRange(1, self.p)
        self.x = getRandomRange(2, self.p) # x is private key
        self.y = pow(self.g, self.x, self.p) # y is public key
        self.k = getRandomRange(1, self.p)
        while GCD(self.k, self.p - 1) != 1:
            self.k = getRandomRange(1, self.p)
        print(f"{self.p :} {self.g :} {self.y :}")
        print(f"k: {self.k}")
    def hash_m(self, m):
        sha = hashlib.sha256()
        sha.update(long_to_bytes(m))
        return bytes_to_long(sha.digest())
    def sign(self, m):
        assert m > 0
        assert m < self.p
        h = self.hash_m(m)
        r = pow(self.g, self.k, self.p)
        s = ((h - self.x * r) * pow(self.k, -1, self.p - 1)) % (self.p - 1) 
        return (r, s)
    def verify(self, m, signature):
        r, s = signature
        assert r >= 1
        assert r < self.p
        h = self.hash_m(m)
        lhs = pow(self.g, h, self.p)
        rhs = (pow(self.y, r, self.p) * pow(r, s, self.p)) % self.p
        return lhs == rhs 

def main():
    print("Welcome to my super uwu secure digital signature scheme!")
    uwu = Uwu(KEY_LENGTH)
    sign_count = 0   
    while True:
        print("1. Show me some of your cutesy patootie signatures!")
        print("2. Get some of my uwu signatures (max 2)")
        choice = int(input("> "))
        if choice == 1:
            data = json.loads(input("Send me a message and a signature: "))
            m, r, s = data["m"], data["r"], data["s"]
            if m == bytes_to_long(b"gib flag pls uwu"):
                if uwu.verify(m, (r, s)):
                    print("Very cutesy, very mindful, very demure!")
                    print(FLAG)
                    exit()
                else:
                    print("Very cutesy, but not very mindful")
                    exit()
            else:
                print("Not very cutesy")
                exit()
        elif choice == 2:
            if sign_count >= 2:
                print("Y-Y-You'd steal from poor me? U_U")
                exit()
            data = json.loads(input("Send me a message: "))
            m = data["m"]
            if type(m) is not int or m == bytes_to_long(b"gib flag pls uwu"):
                print("Y-Y-You'd trick poor me? U_U")
                exit()
            r, s = uwu.sign(m)
            print(f"Here's your uwu signature! {s :}")
            sign_count += 1
        else:
            print("Not very smart of you OmO")
            exit()

if __name__ == "__main__":
    main()
```
Đầu tiên là sinh các tham số. Ta có các số $\displaystyle p,g,x,y,k$. $\displaystyle p$ là một số nguyên tố có độ lớn 2048 bit. 

Tiếp đến nó sẽ tính $\displaystyle y=g^{x}$ trong đó $\displaystyle x$ là khóa bí mật còn $\displaystyle y$ là khóa công khai. $\displaystyle k$ là số được chọn thỏa mãn $\displaystyle \gcd( k,p-1) =1$. 

Tiếp theo là hàm $\displaystyle HASH( m)$. Nó sẽ tính hash của một số nguyên $\displaystyle m$ và trả về giá trị dưới dạng bytes. 

Hàm sign sẽ kí một message $\displaystyle m$ bằng cách tính $\displaystyle h=HASH( m)$. Sau đó nó sẽ tính $\displaystyle r=g^{k}\bmod p$ và $\displaystyle s=( h-xr) \times k^{-1}\bmod( p-1)$. Ta sẽ nhận được cặp $\displaystyle ( r,s)$.

Để verify chữ kí thì ta cần nhập một cặp số $\displaystyle ( r,s)$ vào. Sau đó hàm sẽ kiểm tra điều kiện 

$$\begin{equation*}
g^{h} \equiv \left( y^{r} \times r^{s}\right)\bmod p
\end{equation*}$$

Nếu thỏa thì chữ kí là hợp lệ.

**Chứng minh** $\displaystyle g^{h} =y^{r} \times r^{s}\bmod p$. 

Đầu tiên ta có $\displaystyle y=g^{x}\bmod p$ thì khi đó $\displaystyle y^{r} =g^{xr}\bmod p$. Còn $\displaystyle r^{s} =g^{ks}\bmod p$ cho nên $\displaystyle y^{r} \times r^{s} =g^{xr+ks}\bmod p=g^{h}\bmod p$ vì $\displaystyle s=( h-xr) \times k^{-1}\bmod p-1$. Mà ta có tính chất $\displaystyle g^{a} =g^{b}\bmod p$ khi và chỉ khi $\displaystyle a\equiv b\bmod p-1$. Vậy ta có điều phải chứng minh. 

Bây giờ để lấy lại flag thì ta cần gửi một chữ kí hợp lệ của message `b'gib flag pls uwu'`. 

Để forge chữ kí thì ta cần có được giá trị của $\displaystyle x$. Ta có thể tính lại $\displaystyle x$ bằng một cặp $\displaystyle ( r,s)$ như sau:

Giả sử ta có 

$$\begin{gather*}
s=( h-xr) \times k^{-1}\bmod p-1\\
\Longrightarrow sk=h-xr\bmod p-1\\
\Longrightarrow \frac{h-sk}{r} =x\bmod p-1
\end{gather*}$$

Để tính được $\displaystyle x$ thì cần điều kiện $\displaystyle \gcd( r,p-1) =1$. $\displaystyle r=g^{k}\bmod p$ nên tương đương với điều kiện $\displaystyle ( g,p-1) =1$. Hmm cái này thì không chắc chắn 100\% nên mình spam server cho tới khi nào nó nguyên tố cùng nhau thì thôi. 

Còn nếu không muốn dựa vào vận may thì có thể gửi 2 msg khác nhau và giải hệ phương trình tìm lại $x$. 

Code giải:

```python
from pwn import *
from Crypto.Util.number import *
import hashlib 
import json
from math import gcd
r = remote("challs.nusgreyhats.org", 33301)

def hash_m(m):
	sha = hashlib.sha256()
	sha.update(long_to_bytes(m))
	return bytes_to_long(sha.digest())

r.recvuntil(b"Welcome to my super uwu secure digital signature scheme!\n")
line = r.recvline().decode()
p, g, y = map(int,line.strip().split())
line = r.recvline().decode()
k = int(line.strip().split(":")[1].strip())
log.info(f"p = {p}")
log.info(f"g = {g}")
log.info(f"y = {y}")
log.info(f"k = {k}")

# get sign

def get_sign(m):
	r.sendlineafter("> ",b"2")
	r.sendlineafter(b"Send me a message: ",json.dumps({"m":m}).encode())
	line = r.recvline()
	s = int(line.strip().split()[-1])
	return s
r_forge = pow(g,k,p)
assert gcd(r_forge,p-1) == 1
m = 12345
h = hash_m(m)
s = get_sign(m)
r_inv = pow(r_forge,-1,p-1)
x = ((h-s*k)*r_inv) % (p-1)
msg = b"gib flag pls uwu"
m_forge = bytes_to_long(msg)
h_forge = hash_m(m_forge)
s_forge = ((h_forge - x*r_forge) * pow(k,-1,p-1)) % (p-1)
r.sendlineafter("> ",b"1")
payload = {"m" : m_forge, "r":r_forge, "s": s_forge}
r.sendlineafter("Send me a message and a signature:", json.dumps(payload).encode())
r.interactive()
```
Flag: `grey{h_h_H_h0wd_y0u_Do_tH4T_OMO}`
